---
title: 'Language Support Overview'
description: 'Supported programming languages and execution details'
---

## Supported Languages

LLM-Firecracker supports **45 programming languages** across multiple categories, each with its own optimized rootfs image.

### Main Languages

<CardGroup cols={3}>
  <Card title="Python" icon="python" href="/languages/python">
    Python 3.10 with pip
  </Card>
  <Card title="Node.js" icon="node-js" href="/languages/nodejs">
    Node.js 20 LTS
  </Card>
  <Card title="TypeScript" icon="js" href="/languages/typescript">
    TypeScript 5.x with ts-node
  </Card>
  <Card title="Go" icon="golang" href="/languages/go">
    Go 1.22.3
  </Card>
  <Card title="Java" icon="java" href="/languages/java">
    OpenJDK 17
  </Card>
  <Card title="Bash" icon="terminal" href="/languages/bash">
    Bash 5.1 + GNU coreutils
  </Card>
</CardGroup>

### Systems Languages

<CardGroup cols={3}>
  <Card title="Rust" icon="rust" href="/languages/rust">
    Rust stable (1.91+)
  </Card>
  <Card title="C" icon="c" href="/languages/c">
    GCC 12 with standard library
  </Card>
  <Card title="C++" icon="c" href="/languages/cpp">
    G++ 12 with STL
  </Card>
  <Card title="D" icon="code" href="/languages/d">
    DMD/LDC compiler
  </Card>
  <Card title="Zig" icon="code" href="/languages/zig">
    Zig 0.11+ compiler
  </Card>
  <Card title="Assembly" icon="microchip" href="/languages/assembly">
    NASM x86_64 assembler
  </Card>
</CardGroup>

### JVM Languages

<CardGroup cols={3}>
  <Card title="Kotlin" icon="k" href="/languages/kotlin">
    Kotlin 1.9+ with JVM
  </Card>
  <Card title="Scala" icon="s" href="/languages/scala">
    Scala 3.x with JVM
  </Card>
  <Card title="Groovy" icon="g" href="/languages/groovy">
    Apache Groovy 4.x
  </Card>
  <Card title="Clojure" icon="brackets-curly" href="/languages/clojure">
    Clojure 1.11+ Lisp dialect
  </Card>
</CardGroup>

### Scripting Languages

<CardGroup cols={3}>
  <Card title="Ruby" icon="gem" href="/languages/ruby">
    Ruby 3.x interpreter
  </Card>
  <Card title="PHP" icon="php" href="/languages/php">
    PHP 8.x CLI
  </Card>
  <Card title="Perl" icon="code" href="/languages/perl">
    Perl 5.x interpreter
  </Card>
  <Card title="Lua" icon="moon" href="/languages/lua">
    Lua 5.4 interpreter
  </Card>
  <Card title="Tcl" icon="terminal" href="/languages/tcl">
    Tcl 8.6 scripting
  </Card>
  <Card title="AWK" icon="terminal" href="/languages/awk">
    GNU AWK text processing
  </Card>
</CardGroup>

### Functional Languages

<CardGroup cols={3}>
  <Card title="Haskell" icon="lambda" href="/languages/haskell">
    GHC Haskell compiler
  </Card>
  <Card title="Elixir" icon="droplet" href="/languages/elixir">
    Elixir with Erlang/OTP
  </Card>
  <Card title="Erlang" icon="message" href="/languages/erlang">
    Erlang/OTP runtime
  </Card>
  <Card title="OCaml" icon="code" href="/languages/ocaml">
    OCaml compiler
  </Card>
  <Card title="F#" icon="hashtag" href="/languages/fsharp">
    F# with .NET
  </Card>
  <Card title="Scheme" icon="brackets-round" href="/languages/scheme">
    MIT Scheme interpreter
  </Card>
</CardGroup>

### Modern Compiled Languages

<CardGroup cols={3}>
  <Card title="Crystal" icon="gem" href="/languages/crystal">
    Crystal - Ruby-like, C-speed
  </Card>
  <Card title="Nim" icon="code" href="/languages/nim">
    Nim - Python-like, C-speed
  </Card>
  <Card title="V" icon="code" href="/languages/vlang">
    V language compiler
  </Card>
  <Card title="Swift" icon="swift" href="/languages/swift">
    Swift compiler
  </Card>
  <Card title="C#" icon="hashtag" href="/languages/csharp">
    C# with .NET runtime
  </Card>
</CardGroup>

### Scientific Computing

<CardGroup cols={3}>
  <Card title="R" icon="chart-line" href="/languages/r">
    R statistical computing
  </Card>
  <Card title="Julia" icon="infinity" href="/languages/julia">
    Julia scientific computing
  </Card>
  <Card title="Octave" icon="calculator" href="/languages/octave">
    GNU Octave (MATLAB-compatible)
  </Card>
  <Card title="Fortran" icon="superscript" href="/languages/fortran">
    GFortran compiler
  </Card>
</CardGroup>

### Database & Query Languages

<CardGroup cols={2}>
  <Card title="SQLite" icon="database" href="/languages/sqlite">
    SQLite embedded database
  </Card>
  <Card title="jq" icon="filter" href="/languages/jq">
    jq JSON processor
  </Card>
</CardGroup>

### Legacy Languages

<CardGroup cols={2}>
  <Card title="COBOL" icon="building-columns" href="/languages/cobol">
    GnuCOBOL for business apps
  </Card>
  <Card title="Pascal" icon="code" href="/languages/pascal">
    Free Pascal compiler
  </Card>
</CardGroup>

## Language Comparison

### Performance Tiers

| Tier | Languages | Boot + Execute | Use Cases |
|------|-----------|----------------|-----------|
| **Fast** (~2-3s) | Python, Node.js, Bash, Ruby, PHP, Perl, Lua, Tcl, AWK, SQLite, jq | ~2.5-3.2s | Scripting, rapid prototyping |
| **Medium** (~3-5s) | Go, Java, Kotlin, Scala, Groovy, Clojure, Elixir, Erlang | ~3.5-5s | Enterprise, concurrent apps |
| **Compiled** (~4-8s) | C, C++, Rust, D, Zig, Crystal, Nim, Haskell, OCaml, F#, Swift | ~4-8s | Performance-critical code |
| **Heavy** (~5-10s) | Julia, R, Octave, .NET (C#, F#), COBOL | ~5-10s | Scientific computing, legacy |

### Detailed Comparison

| Language | Type | Rootfs Size | Boot + Execute | Best For |
|----------|------|-------------|----------------|----------|
| Python | Interpreted | 600 MB | ~3.1s | Data science, scripting |
| Node.js | Interpreted | 700 MB | ~3.2s | Web, async operations |
| TypeScript | Transpiled | 800 MB | ~3.5s | Type-safe JavaScript |
| Go | Compiled | 700 MB | ~3.5s | Systems, concurrency |
| Rust | Compiled | 2 GB | ~5-8s | Performance, safety |
| Java | JVM | 900 MB | ~4s | Enterprise applications |
| Kotlin | JVM | 1 GB | ~4.5s | Modern JVM development |
| C | Compiled | 500 MB | ~3s | Systems programming |
| C++ | Compiled | 600 MB | ~3.5s | High-performance apps |
| Ruby | Interpreted | 600 MB | ~3s | Scripting, web |
| PHP | Interpreted | 600 MB | ~3s | Web scripting |
| Bash | Interpreted | 512 MB | ~3.0s | Shell scripting |
| Haskell | Compiled | 1.5 GB | ~6s | Functional programming |
| Elixir | BEAM | 800 MB | ~4s | Concurrent systems |
| Julia | JIT | 1.5 GB | ~8s | Scientific computing |
| SQLite | Query | 400 MB | ~2.5s | Database operations |
| COBOL | Compiled | 600 MB | ~4s | Business logic |

<Note>
  Times include VM boot (~3s) + code execution. Actual code execution times vary based on complexity.
</Note>

## Execution Models

### Interpreted Languages

Python, Node.js, Ruby, PHP, Perl, Lua, Tcl, Bash, R are executed directly by their interpreters:

<Frame>
  <img src="/images/execution-interpreted.svg" alt="Interpreted Languages Execution Flow" />
</Frame>

### Compiled Languages

C, C++, Go, Rust, D, Zig, Haskell, Crystal, Nim, COBOL require compilation:

<Frame>
  <img src="/images/execution-compiled.svg" alt="Compiled Languages Execution Flow" />
</Frame>

### JVM Languages

Java, Kotlin, Scala, Groovy, Clojure use the JVM:

<Frame>
  <img src="/images/execution-jvm.svg" alt="JVM Languages Execution Flow" />
</Frame>

### BEAM Languages

Elixir and Erlang run on the BEAM virtual machine:

<Frame>
  <img src="/images/execution-beam.svg" alt="BEAM Languages Execution Flow" />
</Frame>

## Language Configuration

Each language is configured in `pkg/guest/executor.go`:

```go
type LanguageConfig struct {
    Name       string   // Language identifier ("python", "node", etc.)
    Extension  string   // File extension (".py", ".js", etc.)
    Command    string   // Interpreter/compiler command
    Args       []string // Additional arguments
    NeedsBuild bool     // Whether compilation is required
    BuildCmd   string   // Compiler command (if compiled)
    BuildArgs  []string // Compiler arguments
}

// Example configurations
languages := map[string]LanguageConfig{
    "python": {
        Name:      "python",
        Extension: ".py",
        Command:   "python3",
    },
    "rust": {
        Name:       "rust",
        Extension:  ".rs",
        NeedsBuild: true,
        BuildCmd:   "rustc",
        BuildArgs:  []string{"-o", "runbin"},
    },
    "kotlin": {
        Name:       "kotlin",
        Extension:  ".kt",
        NeedsBuild: true,
        BuildCmd:   "kotlinc",
        BuildArgs:  []string{"-include-runtime", "-d", "Main.jar"},
        Command:    "java",
        Args:       []string{"-jar", "Main.jar"},
    },
    // ... 42+ more languages
}
```

## Environment Variables

The executor sets these environment variables for all languages:

```go
cmd.Env = append(os.Environ(),
    "HOME=/tmp",
    "TMPDIR=/tmp",
    // Go
    "GOCACHE=/tmp/go-cache",
    "GOPATH=/tmp/go",
    "GOROOT=/usr/local/go",
    // Rust
    "CARGO_HOME=/opt/cargo",
    "RUSTUP_HOME=/opt/rustup",
    // JVM
    "JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64",
    // .NET
    "DOTNET_ROOT=/usr/share/dotnet",
    // Julia
    "JULIA_DEPOT_PATH=/tmp/julia",
    // PATH
    "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:...",
)
```

## Choosing the Right Language

<AccordionGroup>
  <Accordion title="For Scripting & Prototyping">
    **Python, Node.js, Ruby, PHP, Perl, Lua**

    - Fast startup times (~3s)
    - Rich standard libraries
    - Great for quick tasks
    - Easy to read and maintain
  </Accordion>

  <Accordion title="For Performance-Critical Code">
    **Rust, C, C++, Go, Zig**

    - Compiled to native code
    - Zero-cost abstractions
    - Memory safety (Rust, Go)
    - Best for compute-intensive tasks
  </Accordion>

  <Accordion title="For Enterprise Applications">
    **Java, Kotlin, Scala, C#, F#**

    - Strong typing
    - Rich ecosystems
    - Good for complex business logic
    - Cross-platform support
  </Accordion>

  <Accordion title="For Functional Programming">
    **Haskell, Elixir, Erlang, OCaml, Clojure, Scheme**

    - Immutable data structures
    - Pattern matching
    - Concurrent programming
    - Mathematical elegance
  </Accordion>

  <Accordion title="For Scientific Computing">
    **Julia, R, Octave, Python, Fortran**

    - Numerical computing
    - Statistical analysis
    - Linear algebra
    - Data visualization
  </Accordion>

  <Accordion title="For Data Processing">
    **SQLite, jq, AWK, Python**

    - Query languages
    - Text processing
    - JSON manipulation
    - Data transformation
  </Accordion>

  <Accordion title="For Legacy Systems">
    **COBOL, Fortran, Pascal**

    - Business applications
    - Scientific computing
    - Educational purposes
    - Migration projects
  </Accordion>
</AccordionGroup>

## Performance Benchmarks

### Fibonacci(30) Benchmark

| Language | Execution Time | Notes |
|----------|----------------|-------|
| C | ~0.003s | Direct compilation |
| Rust | ~0.005s | Zero-cost abstractions |
| Go | ~0.01s | Compiled, optimized |
| Java | ~0.02s | JIT optimization |
| Node.js | ~0.1s | V8 JIT optimization |
| Python | ~0.3s | Recursive implementation |
| Ruby | ~0.5s | Interpreted |
| Bash | ~8s | Recursive, very slow |

<Note>
  Times exclude VM boot. Includes compilation time for compiled languages.
</Note>

### Hello World (Total Time Including Boot)

| Language | Total Time | Compile | Execute |
|----------|------------|---------|---------|
| Bash | 3010ms | - | 10ms |
| Python | 3050ms | - | 50ms |
| SQLite | 3020ms | - | 20ms |
| Node.js | 3100ms | - | 100ms |
| Go | 3500ms | 450ms | 50ms |
| Java | 4000ms | 800ms | 200ms |
| Rust | 5000ms | 1900ms | 100ms |
| Haskell | 6000ms | 2800ms | 200ms |

## Adding Custom Languages

To add support for a new language:

<Steps>
  <Step title="Create rootfs image">
    ```bash
    # Create new rootfs with language runtime
    task aws:create-rootfs-{lang}
    ```
  </Step>

  <Step title="Update executor.go">
    Add language configuration:
    ```go
    "newlang": {
        Name:       "newlang",
        Extension:  ".nlg",
        Command:    "newlang",
        Args:       []string{"run"},
        NeedsBuild: false,
    },
    ```
  </Step>

  <Step title="Rebuild and deploy">
    ```bash
    task build:infra-operator-linux
    task aws:deploy
    ```
  </Step>

  <Step title="Test">
    ```bash
    task aws:test LANG=newlang CODE="print('hello')"
    ```
  </Step>
</Steps>

## Limitations

### Common Limitations

- **No network access**: VMs don't have network connectivity
- **No persistent storage**: Files are lost after execution
- **Memory limit**: 512 MiB by default
- **Timeout**: Configurable, default 10 seconds

### Language-Specific Limitations

| Language | Limitations |
|----------|-------------|
| Python | No external packages (unless in rootfs) |
| Node.js | No npm install during execution |
| Go | go mod not supported inline |
| Rust | No cargo, only rustc |
| Java | No external JARs |
| Kotlin | No Gradle/Maven |
| Haskell | No cabal packages |
| Julia | No Pkg packages |
| R | No CRAN packages |
| .NET | No NuGet packages |
| Elixir | No Mix dependencies |

<Warning>
  All languages run in isolated environments without network access. External dependencies must be pre-installed in the rootfs image.
</Warning>
