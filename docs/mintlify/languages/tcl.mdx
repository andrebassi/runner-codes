---
title: 'Tcl'
description: 'Tcl scripting language'
---

## Overview

Tcl (Tool Command Language) is a dynamic scripting language known for its simplicity and extensibility. LLM-Firecracker provides Tcl for scripting and automation tasks.

<Card title="Tcl" icon="terminal">
  Tcl interpreter with standard library.
</Card>

## Specifications

| Property | Value |
|----------|-------|
| Docker Image | `debian:bookworm-slim` + tcl |
| Version | Tcl 8.6.13 |
| Rootfs Size | 200 MB |
| Execution | Interpreted |
| File Extension | `.tcl` |
| Run Command | `tclsh {file}` |
| Execution Time | ~9ms |

## Infrastructure

```bash
# 1. Create Rootfs from Docker (custom build with tcl)
# Build: FROM debian:bookworm-slim + apt-get install tcl
sudo infra.operator rootfs from-docker --name tcl --image tcl:custom --size 200

# 2. Create Snapshot
sudo infra.operator snapshot create --lang tcl --mem 512 --vcpus 1

# 3. Upload to S3
sudo infra.operator rootfs upload --lang tcl --bucket llm-firecracker
sudo infra.operator snapshot upload --lang tcl --bucket llm-firecracker

# 4. Test Execution
sudo infra.operator host --lang tcl --code 'puts "Hello from Tcl [info patchlevel]"' --mem 512 --vcpus 1 --snapshot

# Output:
# {
#   "status": "success",
#   "stdout": "Hello from Tcl 8.6.13\n",
#   "executionTime": "~9ms"
# }
```

## Examples

### Hello World

<CodeGroup>
```json Request
{
  "trace_id": "tcl-hello-001",
  "lang": "tcl",
  "code": "puts \"Hello from Tcl!\"",
  "timeout": 10
}
```

```json Response
{
  "trace_id": "tcl-hello-001",
  "stdout": "Hello from Tcl!\n",
  "stderr": "",
  "exit_code": 0
}
```
</CodeGroup>

### Variables and Expressions

<CodeGroup>
```json Request
{
  "trace_id": "tcl-vars-001",
  "lang": "tcl",
  "code": "set x 10\nset y 20\nputs \"Sum: [expr {$x + $y}]\"\nputs \"Product: [expr {$x * $y}]\"",
  "timeout": 10
}
```

```json Response
{
  "trace_id": "tcl-vars-001",
  "stdout": "Sum: 30\nProduct: 200\n",
  "stderr": "",
  "exit_code": 0
}
```
</CodeGroup>

### Lists

<CodeGroup>
```json Request
{
  "trace_id": "tcl-list-001",
  "lang": "tcl",
  "code": "set numbers {1 2 3 4 5}\nputs \"List: $numbers\"\nputs \"Length: [llength $numbers]\"\nputs \"First: [lindex $numbers 0]\"\nputs \"Last: [lindex $numbers end]\"",
  "timeout": 10
}
```

```json Response
{
  "trace_id": "tcl-list-001",
  "stdout": "List: 1 2 3 4 5\nLength: 5\nFirst: 1\nLast: 5\n",
  "stderr": "",
  "exit_code": 0
}
```
</CodeGroup>

### Procedures

<CodeGroup>
```json Request
{
  "trace_id": "tcl-proc-001",
  "lang": "tcl",
  "code": "proc factorial {n} {\n    if {$n <= 1} {\n        return 1\n    }\n    return [expr {$n * [factorial [expr {$n - 1}]]}]\n}\n\nputs \"5! = [factorial 5]\"\nputs \"7! = [factorial 7]\"",
  "timeout": 10
}
```

```json Response
{
  "trace_id": "tcl-proc-001",
  "stdout": "5! = 120\n7! = 5040\n",
  "stderr": "",
  "exit_code": 0
}
```
</CodeGroup>

### Complex Test: Comprehensive Tcl

<CodeGroup>
```json Request
{
  "trace_id": "tcl-complex-001",
  "lang": "tcl",
  "code": "puts \"=== Tcl Complex Test ===\"\nputs \"\"\n\n# Test 1: Fibonacci\nputs \"1. Fibonacci sequence:\"\nproc fib {n} {\n    if {$n <= 1} { return $n }\n    return [expr {[fib [expr {$n-1}]] + [fib [expr {$n-2}]]}]\n}\nset fibs {}\nfor {set i 0} {$i < 10} {incr i} {\n    lappend fibs [fib $i]\n}\nputs \"   First 10: $fibs\"\n\n# Test 2: List operations\nputs \"\"\nputs \"2. List operations:\"\nset numbers {64 34 25 12 22 11 90}\nputs \"   Input: $numbers\"\nset sorted [lsort -integer $numbers]\nputs \"   Sorted: $sorted\"\n\n# Test 3: Dictionaries\nputs \"\"\nputs \"3. Dictionaries:\"\nset person [dict create name Alice age 30 city NYC]\ndict for {key value} $person {\n    puts \"   $key: $value\"\n}\n\n# Test 4: String operations\nputs \"\"\nputs \"4. String operations:\"\nset text \"Hello, World!\"\nputs \"   Original: $text\"\nputs \"   Upper: [string toupper $text]\"\nputs \"   Lower: [string tolower $text]\"\nputs \"   Length: [string length $text]\"\n\n# Test 5: Array operations\nputs \"\"\nputs \"5. Array operations:\"\narray set ages {Alice 30 Bob 25 Charlie 35}\nforeach name [array names ages] {\n    puts \"   $name: $ages($name)\"\n}\n\n# Test 6: Math expressions\nputs \"\"\nputs \"6. Math expressions:\"\nset nums {1 2 3 4 5 6 7 8 9 10}\nset sum 0\nforeach n $nums { set sum [expr {$sum + $n}] }\nputs \"   Numbers: $nums\"\nputs \"   Sum: $sum\"\nputs \"   Average: [expr {$sum / [llength $nums]}]\"\n\n# Test 7: Control flow\nputs \"\"\nputs \"7. Control flow:\"\nfor {set i 1} {$i <= 5} {incr i} {\n    if {$i % 2 == 0} {\n        puts \"   $i is even\"\n    } else {\n        puts \"   $i is odd\"\n    }\n}\n\n# Test 8: String matching\nputs \"\"\nputs \"8. String matching:\"\nset words {apple banana apricot cherry avocado}\nset matches {}\nforeach w $words {\n    if {[string match \"a*\" $w]} {\n        lappend matches $w\n    }\n}\nputs \"   Words starting with 'a': $matches\"\n\nputs \"\"\nputs \"=== All tests passed ===\"",
  "timeout": 30
}
```

```json Response
{
  "trace_id": "tcl-complex-001",
  "stdout": "=== Tcl Complex Test ===\n\n1. Fibonacci sequence:\n   First 10: 0 1 1 2 3 5 8 13 21 34\n\n2. List operations:\n   Input: 64 34 25 12 22 11 90\n   Sorted: 11 12 22 25 34 64 90\n\n3. Dictionaries:\n   name: Alice\n   age: 30\n   city: NYC\n\n4. String operations:\n   Original: Hello, World!\n   Upper: HELLO, WORLD!\n   Lower: hello, world!\n   Length: 13\n\n5. Array operations:\n   Alice: 30\n   Bob: 25\n   Charlie: 35\n\n6. Math expressions:\n   Numbers: 1 2 3 4 5 6 7 8 9 10\n   Sum: 55\n   Average: 5\n\n7. Control flow:\n   1 is odd\n   2 is even\n   3 is odd\n   4 is even\n   5 is odd\n\n8. String matching:\n   Words starting with 'a': apple apricot avocado\n\n=== All tests passed ===\n",
  "stderr": "",
  "exit_code": 0
}
```
</CodeGroup>

## Limitations

<Warning>
  The Tcl environment has the following limitations:
</Warning>

1. **Standard library only**: No Tcl packages
2. **No Tk**: GUI operations not available
3. **No network**: Socket operations will fail
4. **Memory limit**: 512 MiB

## Best Practices

<AccordionGroup>
  <Accordion title="Use braces for expressions">
    Always use braces in expr: `expr {$a + $b}` instead of `expr $a + $b`.
  </Accordion>

  <Accordion title="Use proc for functions">
    Define reusable code with proc command.
  </Accordion>
</AccordionGroup>
