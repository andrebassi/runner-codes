---
title: 'Run Commands'
description: 'Execute code in isolated Firecracker microVMs'
---

## Overview

The `run` command executes code in an isolated Firecracker microVM. It automatically loads the appropriate snapshot (downloading from S3 if necessary) and sends the code to the guest mode (`infra.operator guest`) for execution.

## Commands

### run

Execute code in a microVM.

```bash
infra.operator run --lang <language> [--code <code> | --file <path>] [flags]
```

**Flags:**

| Flag | Short | Description | Default |
|------|-------|-------------|---------|
| `--lang` | `-l` | Language runtime (required) | - |
| `--code` | `-c` | Inline code to execute | - |
| `--file` | `-f` | File to execute | - |
| `--timeout` | `-t` | Execution timeout in seconds | `30` |

<Note>
  Either `--code` or `--file` must be provided, but not both.
</Note>

## Examples

### Inline Code Execution

```bash
# Python
infra.operator run --lang python --code "print('Hello from Firecracker!')"

# Node.js
infra.operator run --lang nodejs --code "console.log('Hello from Firecracker!')"

# Go
infra.operator run --lang go --code 'package main
func main() {
    println("Hello from Firecracker!")
}'

# Rust
infra.operator run --lang rust --code 'fn main() {
    println!("Hello from Firecracker!");
}'

# Ruby
infra.operator run --lang ruby --code "puts 'Hello from Firecracker!'"
```

### File Execution

```bash
# Execute Python file
infra.operator run --lang python --file script.py

# Execute Node.js file
infra.operator run --lang nodejs --file app.js

# Execute Go file
infra.operator run --lang go --file main.go
```

### Custom Timeout

```bash
# Long-running computation (5 minutes)
infra.operator run --lang python --file compute.py --timeout 300

# Quick script (10 seconds)
infra.operator run --lang bash --code "echo 'fast'" --timeout 10
```

## Output Format

The run command outputs JSON with execution results:

```json
{
  "stdout": "Hello from Firecracker!\n",
  "stderr": "",
  "exit_code": 0,
  "load_time": "209ms",
  "exec_time": "45ms"
}
```

**Fields:**

| Field | Description |
|-------|-------------|
| `stdout` | Standard output from the code |
| `stderr` | Standard error output |
| `exit_code` | Process exit code (0 = success) |
| `load_time` | Time to load the snapshot |
| `exec_time` | Time to execute the code |

## Execution Flow

<Frame>
  <img src="/images/execution-flow.svg" alt="Code Execution Flow" />
</Frame>

## Supported Languages

Execute code in any of the 45 supported languages:

<Tabs>
  <Tab title="Popular">
    ```bash
    # Python
    infra.operator run -l python -c "print('Hello')"

    # Node.js
    infra.operator run -l nodejs -c "console.log('Hello')"

    # TypeScript
    infra.operator run -l typescript -c "console.log('Hello' as string)"

    # Go
    infra.operator run -l go -c 'package main; func main() { println("Hello") }'

    # Rust
    infra.operator run -l rust -c 'fn main() { println!("Hello"); }'
    ```
  </Tab>
  <Tab title="JVM">
    ```bash
    # Java
    infra.operator run -l java -c 'public class Main { public static void main(String[] args) { System.out.println("Hello"); } }'

    # Kotlin
    infra.operator run -l kotlin -c 'fun main() { println("Hello") }'

    # Scala
    infra.operator run -l scala -c 'object Main extends App { println("Hello") }'

    # Groovy
    infra.operator run -l groovy -c 'println "Hello"'
    ```
  </Tab>
  <Tab title="Scripting">
    ```bash
    # Ruby
    infra.operator run -l ruby -c "puts 'Hello'"

    # PHP
    infra.operator run -l php -c "<?php echo 'Hello';"

    # Perl
    infra.operator run -l perl -c 'print "Hello\n";'

    # Lua
    infra.operator run -l lua -c "print('Hello')"

    # Bash
    infra.operator run -l bash -c "echo 'Hello'"
    ```
  </Tab>
  <Tab title="Functional">
    ```bash
    # Haskell
    infra.operator run -l haskell -c 'main = putStrLn "Hello"'

    # Elixir
    infra.operator run -l elixir -c 'IO.puts "Hello"'

    # Erlang
    infra.operator run -l erlang -c 'main() -> io:format("Hello~n").'

    # Clojure
    infra.operator run -l clojure -c '(println "Hello")'

    # Common Lisp
    infra.operator run -l lisp -c '(format t "Hello~%")'
    ```
  </Tab>
</Tabs>

## Error Handling

### Exit Codes

| Exit Code | Meaning |
|-----------|---------|
| 0 | Success |
| 1 | General error |
| 124 | Timeout exceeded |
| 127 | Language not supported |

### Error Examples

```bash
# Syntax error
$ infra.operator run -l python -c "print('Hello"
{
  "stdout": "",
  "stderr": "SyntaxError: EOL while scanning string literal",
  "exit_code": 1
}

# Timeout
$ infra.operator run -l python -c "import time; time.sleep(60)" --timeout 5
{
  "stdout": "",
  "stderr": "Execution timeout exceeded (5s)",
  "exit_code": 124
}

# Unknown language
$ infra.operator run -l unknown -c "print('Hello')"
Error: unknown language: unknown
Available: python, nodejs, go, rust, ...
```

## Performance

### Typical Execution Times

| Phase | Time |
|-------|------|
| Snapshot load (cached) | ~200ms |
| Snapshot download (S3) | ~2.4s |
| Code execution | ~50ms-5s |
| Total (cached) | ~250ms+ |
| Total (first run) | ~2.7s+ |

### Optimization Tips

<CardGroup cols={2}>
  <Card title="Pre-cache Snapshots" icon="download">
    Download snapshots before execution:
    ```bash
    infra.operator snapshot download --lang python
    ```
  </Card>
  <Card title="Warm Pool" icon="fire">
    Keep VMs running for instant execution (coming soon)
  </Card>
</CardGroup>

## Taskfile Integration

```bash
# Execute inline code
task -t Taskfile.cli.yaml run LANG=python CODE='print(1)'

# Execute file
task -t Taskfile.cli.yaml run:file LANG=python FILE=script.py

# Remote execution on EC2
task -t Taskfile.cli.yaml remote:run LANG=python CODE='print(1)'
```

## Benchmark Command

Test execution performance across all languages:

```bash
# Benchmark all 45 languages
infra.operator benchmark --all

# Output:
# ==============================================
#   BENCHMARK: Snapshot Load Time
# ==============================================
# Testing 45 languages...
#
# [1/45] python: LOAD=209ms [OK]
# [2/45] nodejs: LOAD=215ms [OK]
# [3/45] go: LOAD=198ms [OK]
# ...
# [45/45] cobol: LOAD=195ms [OK]
#
# ==============================================
#   BENCHMARK REPORT
# ==============================================
#
# Results: 45/45 PASSED, 0 FAILED
#
# Average Load Time: 220ms
# Total Load Time: 9.9s

# Benchmark specific languages
infra.operator benchmark --langs python,nodejs,go,rust
```

## Security

Each execution is fully isolated:

- **Process isolation**: Runs in separate microVM
- **Memory isolation**: Dedicated memory space
- **No network**: No network access by default
- **Timeout enforcement**: Hard timeout via Firecracker API
- **Read-write rootfs**: Changes are ephemeral

<Warning>
  Code is executed with full guest privileges. Do not execute untrusted code without proper sandboxing.
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Snapshot not found">
    Download the snapshot first:
    ```bash
    infra.operator snapshot download --lang python
    ```
  </Accordion>

  <Accordion title="Execution timeout">
    Increase the timeout:
    ```bash
    infra.operator run --lang python --file long_script.py --timeout 300
    ```
  </Accordion>

  <Accordion title="Out of memory">
    The snapshot was created with insufficient memory. Recreate with more:
    ```bash
    infra.operator snapshot create --lang java --mem 1024
    ```
  </Accordion>

  <Accordion title="Permission denied on /dev/kvm">
    Add your user to the kvm group:
    ```bash
    sudo usermod -aG kvm $USER
    # Logout and login again
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="HTTP API" icon="server" href="/cli/http-api">
    Use the REST API for programmatic access
  </Card>
  <Card title="Performance" icon="gauge-high" href="/advanced/performance">
    Optimize execution performance
  </Card>
</CardGroup>
